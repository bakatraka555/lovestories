<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Your Transformation - Love Stories Museum</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.3/dist/heic2any.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .template-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }

        .template-info h2 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .template-info p {
            opacity: 0.9;
            font-size: 14px;
        }

        .upload-section {
            margin-bottom: 30px;
        }

        .upload-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .upload-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .upload-option {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .upload-option:hover {
            background: #e9ecef;
            border-color: #764ba2;
        }

        .upload-option input[type="file"] {
            display: none;
        }

        .upload-option label {
            cursor: pointer;
            display: block;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 12px;
            color: #666;
        }

        .upload-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
            flex: 1;
            max-width: 150px;
        }

        .upload-btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .upload-btn:active {
            transform: translateY(0);
        }

        /* ANDROID FIX: Hidden file inputs for separate camera/gallery */
        .android-fix-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        .preview-section {
            margin-bottom: 30px;
        }

        .preview-images {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .preview-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 1;
            background: #f8f9fa;
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .generate-button {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-bottom: 20px;
        }

        .generate-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .generate-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Progress Bar Styles */
        .progress-container {
            margin: 30px 0;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 6px;
            transition: width 0.5s ease;
            width: 0%;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 16px;
            font-weight: 600;
            color: #667eea;
            margin: 10px 0 5px 0;
        }

        .time-estimate {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* Step Indicators */
        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .step {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s;
            position: relative;
        }

        .step.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .step.completed {
            background: #28a745;
            color: white;
        }

        .step-icon {
            font-size: 20px;
            margin-right: 8px;
        }

        .loading-message-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        /* Error Recovery */
        .error-recovery {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .error-recovery h4 {
            color: #856404;
            margin-bottom: 15px;
        }

        .error-recovery-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .retry-button, .save-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .retry-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .retry-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .save-button {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #667eea;
        }

        .save-button:hover {
            background: #e9ecef;
        }

        /* Validation Messages */
        .validation-message {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
            display: none;
        }

        .validation-message.show {
            display: block;
        }

        .validation-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .validation-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .validation-message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .results-section {
            margin-top: 30px;
            display: none;
        }

        .results-section.show {
            display: block;
        }

        .result-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .result-item h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item img,
        .result-item video {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .download-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            text-decoration: none;
            display: inline-block;
        }

        .download-button:hover {
            background: #764ba2;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #c33;
        }

        .info-box {
            background: #e7f3ff;
            color: #0066cc;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #0066cc;
            font-size: 14px;
        }

        @media (max-width: 600px) {
            .upload-options {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 20px;
            }
        }

        /* ANDROID DEBUG PANEL */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            max-width: 300px;
            max-height: 200px;
            overflow: auto;
            display: none;
        }

        .debug-toggle {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            z-index: 1000;
        }

        .debug-log {
            margin: 2px 0;
            padding: 2px;
            border-bottom: 1px solid #444;
            font-family: monospace;
        }

        .debug-log.error {
            color: #ff6b6b;
        }

        .debug-log.success {
            color: #51cf66;
        }

        .debug-log.info {
            color: #339af0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíë Order Your Transformation</h1>
        <p class="subtitle">Upload your photos and get an AI transformation</p>

        <div class="template-info" id="templateInfo">
            <h2>Loading template...</h2>
            <p>Please wait</p>
        </div>

        <div class="upload-section">
            <h3>üì∏ Select Photos</h3>
            <div class="info-box">
                üí° You can upload <strong>1 photo with both of you</strong> or <strong>2 separate photos</strong> (one per person)<br>
                üì± On mobile you can choose a photo from <strong>gallery</strong> or <strong>take a new one with camera</strong>
            </div>
            
            <div class="upload-options">
                <div class="upload-option">
                    <!-- ANDROID FIX: Separate inputs for camera and gallery -->
                    <input type="file" id="coupleImageGallery" class="android-fix-input" accept="image/*" />
                    <input type="file" id="coupleImageCamera" class="android-fix-input" accept="image/*" capture="user" />
                    <div class="upload-icon">üë´</div>
                    <div class="upload-text">Couple in one photo</div>
                    <div class="upload-buttons">
                        <button type="button" class="upload-btn" onclick="triggerAndroidGallery('couple')">üìÅ Gallery</button>
                        <button type="button" class="upload-btn" onclick="triggerAndroidCamera('couple')">üì∑ Camera</button>
                    </div>
                </div>
                <div class="upload-option">
                    <!-- ANDROID FIX: Separate inputs for camera and gallery -->
                    <input type="file" id="person1ImageGallery" class="android-fix-input" accept="image/*" />
                    <input type="file" id="person1ImageCamera" class="android-fix-input" accept="image/*" capture="user" />
                    <div class="upload-icon">üë§</div>
                    <div class="upload-text">Person 1</div>
                    <div class="upload-buttons">
                        <button type="button" class="upload-btn" onclick="triggerAndroidGallery('person1')">üìÅ Gallery</button>
                        <button type="button" class="upload-btn" onclick="triggerAndroidCamera('person1')">üì∑ Camera</button>
                    </div>
                </div>
            </div>
            <div class="upload-options">
                <div class="upload-option" style="grid-column: 1 / -1;">
                    <!-- ANDROID FIX: Separate inputs for camera and gallery -->
                    <input type="file" id="person2ImageGallery" class="android-fix-input" accept="image/*" />
                    <input type="file" id="person2ImageCamera" class="android-fix-input" accept="image/*" capture="user" />
                    <div class="upload-icon">üë§</div>
                    <div class="upload-text">Person 2 (optional)</div>
                    <div class="upload-buttons">
                        <button type="button" class="upload-btn" onclick="triggerAndroidGallery('person2')">üìÅ Gallery</button>
                        <button type="button" class="upload-btn" onclick="triggerAndroidCamera('person2')">üì∑ Camera</button>
                    </div>
                    <div class="upload-hint" style="margin-top: 10px; font-size: 12px; color: #666;">Only if using separate photos</div>
                </div>
            </div>

            <div class="preview-section" id="previewSection" style="display: none;">
                <h3>üëÄ Preview</h3>
                <div class="preview-images" id="previewImages"></div>
            </div>
        </div>

        <!-- Validation Messages -->
        <div id="validationMessage" class="validation-message"></div>
        
        <!-- Error Message with Recovery -->
        <div id="errorMessage" class="error" style="display: none;">
            <div id="errorContent"></div>
            <div class="error-recovery" id="errorRecovery" style="display: none;">
                <h4>What would you like to do?</h4>
                <div class="error-recovery-buttons">
                    <button class="retry-button" onclick="retryGeneration()">üîÑ Try Again</button>
                    <button class="save-button" onclick="saveProgress()">üíæ Save Progress</button>
                </div>
            </div>
        </div>

        <button class="generate-button" id="generateButton" disabled>
            ‚ú® Generate Transformation
        </button>

        <div class="loading" id="loadingSection" style="display: none;">
            <div class="loading-spinner"></div>
            
            <!-- Step Indicators -->
            <div class="step-indicator" id="stepIndicator">
                <div class="step" id="step1" data-step="1">üì§</div>
                <div class="step" id="step2" data-step="2">ü§ñ</div>
                <div class="step" id="step3" data-step="3">‚ú®</div>
                <div class="step" id="step4" data-step="4">üé®</div>
                <div class="step" id="step5" data-step="5">üé≠</div>
                <div class="step" id="step6" data-step="6">‚úÖ</div>
            </div>
            
            <!-- Loading Message -->
            <div class="loading-message-container">
                <span class="step-icon" id="stepIcon">üì§</span>
                <p id="loadingMessage">AI is generating your transformation...</p>
            </div>
            
            <!-- Progress Bar -->
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0%</div>
                <div class="time-estimate" id="timeEstimate">Estimated time: ~2 minutes</div>
            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <h3>üéâ Your Transformation is Ready!</h3>
            <div id="resultsContainer"></div>
        </div>
    </div>

    <!-- ANDROID DEBUG PANEL -->
    <button class="debug-toggle" onclick="toggleDebugPanel()">üêõ Debug</button>
    <div class="debug-panel" id="debugPanel">
        <div style="margin-bottom: 5px; font-weight: bold;">Android Debug Logs:</div>
        <div id="debugLogs"></div>
    </div>

    <script>
        // Get template from URL
        const urlParams = new URLSearchParams(window.location.search);
        const templateId = urlParams.get('template');
        
        // ANDROID DEBUGGING SYSTEM
        const debugLogs = [];
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isChrome = /Chrome/i.test(navigator.userAgent);
        const isMobile = /Mobi/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        // NETWORK MONITORING FOR ANDROID
        let networkStatus = {
            online: navigator.onLine,
            lastCheck: new Date(),
            retryCount: 0,
            lastError: null
        };
        
        function checkNetworkStatus() {
            const wasOnline = networkStatus.online;
            networkStatus.online = navigator.onLine;
            networkStatus.lastCheck = new Date();
            
            if (wasOnline !== networkStatus.online) {
                const status = networkStatus.online ? 'online' : 'offline';
                debugLog(`üåê Network status changed: ${status}`, networkStatus.online ? 'success' : 'error');
                
                if (!networkStatus.online) {
                    showValidationMessage('‚ö†Ô∏è You are offline. Please check your internet connection.', 'warning');
                } else {
                    showValidationMessage('‚úÖ Back online! You can continue.', 'success');
                }
            }
            
            return networkStatus.online;
        }
        
        // Monitor network changes
        window.addEventListener('online', () => {
            networkStatus.online = true;
            networkStatus.lastCheck = new Date();
            debugLog('üåê Device is back online', 'success');
            showValidationMessage('‚úÖ Internet connection restored', 'success');
        });
        
        window.addEventListener('offline', () => {
            networkStatus.online = false;
            networkStatus.lastCheck = new Date();
            debugLog('üåê Device went offline', 'error');
            showError('‚ö†Ô∏è You lost internet connection. Please reconnect and try again.', false);
        });
        
        // Enhanced console.log that also logs to debug panel
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            // Log to console
            console.log(`[DEBUG] ${logEntry}`);
            
            // Add to debug logs array
            debugLogs.push({ message: logEntry, type, timestamp });
            
            // Update debug panel if visible
            updateDebugPanel();
            
            // Also log to our custom debug function
            logToDebugPanel(logEntry, type);
        }
        
        // ANDROID FIX: Network-aware fetch with better error handling
        async function networkAwareFetch(url, options, maxRetries = 2) {
            // Check network before attempting
            if (!checkNetworkStatus()) {
                throw new Error('No internet connection. Please connect to WiFi or mobile data.');
            }
            
            debugLog(`üåê Fetching: ${url}`, 'info');
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    debugLog(`Attempt ${attempt}/${maxRetries}`, 'info');
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000);
                    
                    const fetchOptions = {
                        ...options,
                        signal: controller.signal
                    };
                    
                    const response = await fetch(url, fetchOptions);
                    clearTimeout(timeoutId);
                    
                    // ANDROID FIX: Validate response is not a ProgressEvent
                    if (response.constructor && response.constructor.name === 'ProgressEvent') {
                        debugLog(`Attempt ${attempt}: Got ProgressEvent instead of Response`, 'error');
                        throw new Error('Network error - connection failed');
                    }
                    
                    debugLog(`Attempt ${attempt}: Success (Status: ${response.status})`, 'success');
                    return response;
                    
                } catch (error) {
                    debugLog(`Attempt ${attempt} failed: ${error.message}`, 'error');
                    
                    if (attempt === maxRetries) {
                        // Last attempt failed
                        if (error.name === 'AbortError') {
                            throw new Error('Request timeout - server took too long to respond');
                        } else if (error.constructor && error.constructor.name === 'ProgressEvent') {
                            // Provjeri da li je ureƒëaj stvarno offline
                            if (!navigator.onLine) {
                                throw new Error('Network connection failed. Please check your internet.');
                            } else {
                                throw new Error('Upload failed - please try again. If the problem persists, check your connection.');
                            }
                        } else if (error.message && error.message.includes('Failed to fetch')) {
                            // Provjeri da li je ureƒëaj stvarno offline
                            if (!navigator.onLine) {
                                throw new Error('Could not connect to server. Please check your internet connection.');
                            } else {
                                throw new Error('Server connection failed - please try again.');
                            }
                        }
                        throw error;
                    }
                    
                    // Wait before retry (exponential backoff)
                    const delay = 1000 * attempt;
                    debugLog(`Waiting ${delay}ms before retry...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        function logToDebugPanel(message, type = 'info') {
            const debugLogsDiv = document.getElementById('debugLogs');
            if (!debugLogsDiv) return;
            
            const logElement = document.createElement('div');
            logElement.className = `debug-log ${type}`;
            logElement.textContent = message;
            
            debugLogsDiv.appendChild(logElement);
            
            // Keep only last 20 logs
            const logs = debugLogsDiv.querySelectorAll('.debug-log');
            if (logs.length > 20) {
                logs[0].remove();
            }
            
            // Auto-scroll to bottom
            debugLogsDiv.scrollTop = debugLogsDiv.scrollHeight;
        }
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                updateDebugPanel();
            }
        }
        
        function updateDebugPanel() {
            const debugLogsDiv = document.getElementById('debugLogs');
            if (!debugLogsDiv) return;
            
            // Clear and rebuild
            debugLogsDiv.innerHTML = '';
            
            // Add device info
            logToDebugPanel(`üì± Device: ${navigator.userAgent.substring(0, 50)}...`, 'info');
            logToDebugPanel(`ü§ñ Android: ${isAndroid} | Chrome: ${isChrome} | Mobile: ${isMobile}`, 'info');
            logToDebugPanel(`üåê Platform: ${navigator.platform}`, 'info');
            logToDebugPanel(`üìè Screen: ${window.innerWidth}x${window.innerHeight}`, 'info');
            logToDebugPanel(`üîó URL: ${window.location.href}`, 'info');
            logToDebugPanel('---', 'info');
            
            // Add recent logs
            debugLogs.slice(-10).forEach(log => {
                logToDebugPanel(log.message, log.type);
            });
        }
        
        // Initialize debug logging
        debugLog('=== ANDROID DEBUG INITIALIZED ===', 'success');
        debugLog(`User Agent: ${navigator.userAgent}`, 'info');
        debugLog(`Is Android: ${isAndroid}`, isAndroid ? 'success' : 'info');
        debugLog(`Is Chrome: ${isChrome}`, isChrome ? 'success' : 'info');
        debugLog(`Is Mobile: ${isMobile}`, isMobile ? 'success' : 'info');
        
        // ANDROID FIX: Use separate approach for Android
        const useAndroidFix = isAndroid && isMobile;
        
        let currentTemplate = null;
        let uploadedImages = {
            couple: null,
            person1: null,
            person2: null
        };

        // Load template info
        async function loadTemplateInfo() {
            try {
                const response = await fetch('docs/couples-templates-database.json');
                const data = await response.json();
                currentTemplate = data.templates.find(t => t.id === templateId);
                
                if (currentTemplate) {
                    document.getElementById('templateInfo').innerHTML = `
                        <h2>${currentTemplate.number}. ${currentTemplate.name}</h2>
                        <p>${currentTemplate.description}</p>
                    `;
                    // Provjeri button status nakon uƒçitavanja template-a
                    checkGenerateButton();
                } else {
                    document.getElementById('templateInfo').innerHTML = `
                        <h2>Template not found</h2>
                        <p>Please go back and select a template again</p>
                    `;
                    checkGenerateButton();
                }
            } catch (error) {
                console.error('Error loading template:', error);
                document.getElementById('templateInfo').innerHTML = `
                    <h2>Error loading</h2>
                    <p>Please refresh the page</p>
                `;
            }
        }

        // ANDROID FIX: Separate functions for camera and gallery
        function triggerAndroidGallery(imageType) {
            console.log(`Android Gallery trigger for: ${imageType}`);
            const inputId = `${imageType}ImageGallery`;
            const input = document.getElementById(inputId);
            
            if (!input) {
                console.error(`Input not found: ${inputId}`);
                showValidationMessage('‚ùå Error: Input element not found', 'error');
                return;
            }
            
            // Reset and trigger
            input.value = '';
            input.removeAttribute('capture');
            input.setAttribute('accept', 'image/*');
            
            setTimeout(() => {
                try {
                    input.click();
                } catch (error) {
                    console.error('Android Gallery click error:', error);
                    showValidationMessage('‚ùå Error opening gallery', 'error');
                }
            }, 100);
        }
        
        function triggerAndroidCamera(imageType) {
            console.log(`Android Camera trigger for: ${imageType}`);
            const inputId = `${imageType}ImageCamera`;
            const input = document.getElementById(inputId);
            
            if (!input) {
                console.error(`Input not found: ${inputId}`);
                showValidationMessage('‚ùå Error: Input element not found', 'error');
                return;
            }
            
            // Reset and trigger
            input.value = '';
            input.setAttribute('capture', 'user');
            input.setAttribute('accept', 'image/*');
            
            setTimeout(() => {
                try {
                    input.click();
                } catch (error) {
                    console.error('Android Camera click error:', error);
                    showValidationMessage('‚ùå Error opening camera', 'error');
                }
            }, 100);
        }
        
        // ANDROID FIX: Event listeners for separate inputs
        function setupAndroidInputListeners() {
            // Couple image listeners
            document.getElementById('coupleImageGallery').addEventListener('change', function(e) {
                handleFileSelect(e, 'couple', false);
            });
            document.getElementById('coupleImageCamera').addEventListener('change', function(e) {
                handleFileSelect(e, 'couple', true);
            });
            
            // Person1 image listeners
            document.getElementById('person1ImageGallery').addEventListener('change', function(e) {
                handleFileSelect(e, 'person1', false);
            });
            document.getElementById('person1ImageCamera').addEventListener('change', function(e) {
                handleFileSelect(e, 'person1', true);
            });
            
            // Person2 image listeners
            document.getElementById('person2ImageGallery').addEventListener('change', function(e) {
                handleFileSelect(e, 'person2', false);
            });
            document.getElementById('person2ImageCamera').addEventListener('change', function(e) {
                handleFileSelect(e, 'person2', true);
            });
        }
        
        function handleFileSelect(event, imageType, fromCamera) {
            console.log(`=== ANDROID FILE SELECT: ${imageType} (fromCamera: ${fromCamera}) ===`);
            console.log('Event:', event);
            console.log('Files:', event.target.files);
            
            if (!event.target.files || event.target.files.length === 0) {
                console.log('User cancelled file selection');
                showValidationMessage('‚ùå File selection cancelled', 'warning');
                return;
            }
            
            const file = event.target.files[0];
            
            // DETALJNO LOGIRANJE: Provjeri File objekt iz galerije vs camera
            console.log('=== FILE OBJECT ANALYSIS ===');
            console.log('Source:', fromCamera ? 'CAMERA' : 'GALLERY');
            console.log('File name:', file.name);
            console.log('File type:', file.type);
            console.log('File size:', file.size);
            console.log('File lastModified:', file.lastModified);
            console.log('File has name?', file.name !== undefined && file.name !== null && file.name !== '');
            console.log('File has type?', file.type !== undefined && file.type !== null && file.type !== '');
            console.log('File keys:', Object.keys(file));
            console.log('File constructor:', file.constructor?.name);
            
            // NORMALIZACIJA: Ako galerija vraƒáa File bez name ili type, kreiraj novi File objekt
            let normalizedFile = file;
            if (!fromCamera && (!file.name || !file.type)) {
                console.warn('‚ö†Ô∏è GALLERY FILE MISSING METADATA - Creating normalized File object...');
                
                // Odredi type
                let fileType = file.type;
                if (!fileType) {
                    if (file.name) {
                        const ext = file.name.toLowerCase().split('.').pop();
                        const typeMap = {
                            'jpg': 'image/jpeg',
                            'jpeg': 'image/jpeg',
                            'png': 'image/png',
                            'webp': 'image/webp',
                            'heic': 'image/heic',
                            'heif': 'image/heif'
                        };
                        fileType = typeMap[ext] || 'image/jpeg';
                        console.log('üîß Inferred type from extension:', fileType);
                    } else {
                        fileType = 'image/jpeg'; // Default fallback
                        console.log('üîß Using default type: image/jpeg');
                    }
                }
                
                // Odredi name
                let fileName = file.name;
                if (!fileName) {
                    const timestamp = Date.now();
                    const ext = fileType.includes('png') ? 'png' : 
                               fileType.includes('webp') ? 'webp' : 'jpg';
                    fileName = `gallery-image-${timestamp}.${ext}`;
                    console.log('üîß Generated filename:', fileName);
                }
                
                // Kreiraj novi File objekt iz Blob-a (File je subklasa Blob-a)
                try {
                    normalizedFile = new File([file], fileName, {
                        type: fileType,
                        lastModified: file.lastModified || Date.now()
                    });
                    console.log('‚úÖ Created normalized File object:', {
                        name: normalizedFile.name,
                        type: normalizedFile.type,
                        size: normalizedFile.size
                    });
                } catch (fileError) {
                    console.error('‚ùå Failed to create File object, using original:', fileError);
                    // Fallback: poku≈°aj koristiti original, ali dodaj type ako je moguƒáe
                    if (!file.type && fileType) {
                        // Ako File konstruktor ne radi, koristimo Blob i onda FileReader
                        console.warn('‚ö†Ô∏è File constructor not supported, using Blob approach');
                        normalizedFile = file; // Koristimo original, ali ƒáemo provjeriti u processSelectedFile
                    } else {
                        normalizedFile = file;
                    }
                }
            }
            
            processSelectedFile(normalizedFile, imageType, fromCamera);
        }

        // Common file processing function
        async function processSelectedFile(file, imageType, fromCamera = false) {
            console.log(`=== PROCESSING FILE: ${imageType} (fromCamera: ${fromCamera}) ===`);
            console.log('File details:', {
                name: file.name,
                type: file.type,
                size: file.size,
                lastModified: file.lastModified,
                isAndroid: isAndroid,
                source: fromCamera ? 'CAMERA' : 'GALLERY'
            });
            
            try {
                // Provjeri je li HEIC (sa provjerom da file.type i file.name postoje)
                const isHeic = (file.type && (file.type === 'image/heic' || file.type === 'image/heif')) || 
                               (file.name && (file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')));
                
                console.log('Is HEIC file:', isHeic);
                
                let processedFile = file;
                
                // Ako je HEIC, konvertuj
                if (isHeic) {
                    showValidationMessage('üîÑ Converting Samsung HEIC to JPEG...', 'warning');
                    processedFile = await convertHeicToJpegInBrowser(file);
                    showValidationMessage('‚úÖ Converted successfully!', 'success');
                }
                
                await validateImage(processedFile);
                
                // KRITIƒåNO: Odmah pretvori File u Blob preko Canvas-a
                // Razlog: File objekt mo≈æe postati "consumed" nakon ≈°to se koristi za preview
                // Blob je siguran i mo≈æe se koristiti vi≈°e puta (preview + upload)
                console.log('üé® Converting to clean Blob immediately after validation...');
                const quality = processedFile.size > (5 * 1024 * 1024) ? 0.8 : 0.9;
                const cleanBlob = await convertFileToCleanBlob(processedFile, quality);
                console.log('‚úÖ Clean Blob created:', (cleanBlob.size / 1024 / 1024).toFixed(2) + ' MB');
                
                // Set the BLOB (not File) based on type
                if (imageType === 'couple') {
                    uploadedImages.couple = cleanBlob;
                    uploadedImages.person1 = null;
                    uploadedImages.person2 = null;
                    
                    // ANDROID FIX: Clear other inputs safely
                    clearAllInputsForType('person1');
                    clearAllInputsForType('person2');
                    
                } else if (imageType === 'person1') {
                    uploadedImages.person1 = cleanBlob;
                    uploadedImages.couple = null;
                    
                    // ANDROID FIX: Clear other inputs safely
                    clearAllInputsForType('couple');
                    
                } else if (imageType === 'person2') {
                    uploadedImages.person2 = cleanBlob;
                }
                
                if (!isHeic) {
                    showValidationMessage(`‚úÖ Image validated! (${(cleanBlob.size / 1024 / 1024).toFixed(1)}MB)`, 'success');
                }
                
                checkGenerateButton();
                updatePreview();
                
                console.log('‚úÖ File processing completed successfully for', imageType);
            } catch (error) {
                const errorMsg = error?.message || error?.toString() || 'Invalid image file';
                console.error('‚ùå‚ùå‚ùå Error processing image:', error);
                console.error('‚ùå‚ùå‚ùå Error type:', typeof error);
                console.error('‚ùå‚ùå‚ùå Error constructor:', error?.constructor?.name);
                console.error('‚ùå‚ùå‚ùå Error stack:', error?.stack);
                console.error('‚ùå‚ùå‚ùå File that caused error:', {
                    name: file?.name,
                    type: file?.type,
                    size: file?.size,
                    source: fromCamera ? 'CAMERA' : 'GALLERY'
                });
                showValidationMessage(`‚ùå ${errorMsg}`, 'error');
                // Clear the specific input
                if (imageType === 'couple') {
                    uploadedImages.couple = null;
                } else if (imageType === 'person1') {
                    uploadedImages.person1 = null;
                } else if (imageType === 'person2') {
                    uploadedImages.person2 = null;
                }
                // Poku≈°aj clearati preview
                try {
                    updatePreview();
                    checkGenerateButton();
                } catch (previewError) {
                    console.error('Error clearing preview:', previewError);
                }
            }
        }

        // Update preview
        function updatePreview() {
            const previewSection = document.getElementById('previewSection');
            const previewImages = document.getElementById('previewImages');
            previewImages.innerHTML = '';

            if (uploadedImages.couple) {
                console.log('üì∏ Updating preview for couple image...');
                try {
                    // Koristi URL.createObjectURL umjesto FileReader (br≈æe i pouzdanije)
                    const blobUrl = URL.createObjectURL(uploadedImages.couple);
                    console.log('‚úÖ Preview URL created for couple image');
                    previewImages.innerHTML = `
                        <div class="preview-item">
                            <img src="${blobUrl}" alt="Par">
                            <button class="remove" onclick="removeImage('couple')">√ó</button>
                        </div>
                    `;
                    previewSection.style.display = 'block';
                    checkGenerateButton();
                } catch (error) {
                    console.error('‚ùå Error creating preview for couple image:', error);
                    showValidationMessage('‚ùå Error loading preview: ' + (error.message || 'Unknown error'), 'error');
                }
            } else if (uploadedImages.person1) {
                console.log('üì∏ Updating preview for person1 and/or person2 images...');
                const images = [];
                
                try {
                    if (uploadedImages.person1) {
                        const blobUrl1 = URL.createObjectURL(uploadedImages.person1);
                        console.log('‚úÖ Preview URL created for person1 image');
                        images.push({src: blobUrl1, type: 'person1'});
                    }
                    
                    if (uploadedImages.person2) {
                        const blobUrl2 = URL.createObjectURL(uploadedImages.person2);
                        console.log('‚úÖ Preview URL created for person2 image');
                        images.push({src: blobUrl2, type: 'person2'});
                    }
                    
                    if (images.length > 0) {
                        displayPreview(images);
                    }
                } catch (error) {
                    console.error('‚ùå Error creating preview:', error);
                    showValidationMessage('‚ùå Error loading preview: ' + (error.message || 'Unknown error'), 'error');
                }
            }
        }

        function displayPreview(images) {
            const previewImages = document.getElementById('previewImages');
            previewImages.innerHTML = images.map((img, index) => `
                <div class="preview-item">
                    <img src="${img.src}" alt="Person ${index + 1}">
                    <button class="remove" onclick="removeImage('${img.type}')">√ó</button>
                </div>
            `).join('');
            document.getElementById('previewSection').style.display = 'block';
            checkGenerateButton();
        }

        function removeImage(type) {
            if (type === 'couple') {
                uploadedImages.couple = null;
                // ANDROID FIX: Use safe helper function
                clearAllInputsForType('couple');
                
            } else if (type === 'person1') {
                uploadedImages.person1 = null;
                // ANDROID FIX: Use safe helper function
                clearAllInputsForType('person1');
                
            } else if (type === 'person2') {
                uploadedImages.person2 = null;
                // ANDROID FIX: Use safe helper function
                clearAllInputsForType('person2');
            }
            
            if (!uploadedImages.couple && !uploadedImages.person1) {
                document.getElementById('previewSection').style.display = 'none';
            } else {
                updatePreview();
            }
            checkGenerateButton();
        }

        function checkGenerateButton() {
            const hasImages = uploadedImages.couple || uploadedImages.person1;
            const button = document.getElementById('generateButton');
            const shouldEnable = hasImages && currentTemplate;
            
            console.log('checkGenerateButton:', {
                hasImages: hasImages,
                hasCouple: !!uploadedImages.couple,
                hasPerson1: !!uploadedImages.person1,
                hasPerson2: !!uploadedImages.person2,
                currentTemplate: !!currentTemplate,
                shouldEnable: shouldEnable,
                currentDisabled: button.disabled
            });
            
            button.disabled = !shouldEnable;
            
            // Dodatna provjera - ako je button jo≈° uvijek disabled, poku≈°aj ponovno
            if (!shouldEnable && button.disabled === false) {
                console.warn('Button state mismatch - forcing disabled');
                button.disabled = true;
            } else if (shouldEnable && button.disabled === true) {
                console.warn('Button should be enabled but is disabled - forcing enabled');
                button.disabled = false;
            }
        }

        // Generate transformation
        document.getElementById('generateButton').addEventListener('click', async function() {
            if (!currentTemplate) {
                showError('Template not loaded. Please refresh the page.');
                return;
            }

            const hasImages = uploadedImages.couple || uploadedImages.person1;
            if (!hasImages) {
                showError('Please select at least one photo.');
                return;
            }

            // Check network connection before starting
            if (!navigator.onLine) {
                showError('No internet connection. Please connect to WiFi or mobile data and try again.', false);
                return;
            }

            // Hide error, show loading
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('resultsSection').classList.remove('show');
            document.getElementById('generateButton').disabled = true;
            
            // Start progress tracking
            startProgressTracking();
            
            // Save generation data for retry
            saveGenerationData({
                templateId: currentTemplate.id,
                uploadedImages: uploadedImages,
                isCouple: !!uploadedImages.couple
            });

            try {
                const isCouple = !!uploadedImages.couple;
                
                // NOVO: Uploadaj slike na Bunny.net PRVO (smanjuje request size za 90%+)
                const userId = generateUserId();
                updateLoadingStep(1, 'Uploading images...');
                
                // Upload kroz Netlify function (Bunny.net ne podr≈æava CORS za direktan upload)
                const image1File = uploadedImages.couple || uploadedImages.person1;
                
                if (!image1File) {
                    throw new Error('No image selected. Please select an image first.');
                }
                
                const image1Filename = `${userId}-image1.jpg`;
                
                console.log('üì§ Uploading image1 through Netlify function...');
                console.log('Image1 file size:', image1File.size ? (image1File.size / 1024 / 1024).toFixed(2) + ' MB' : 'unknown');
                console.log('Image1 filename:', image1Filename);
                
                // Timeout wrapper za fetch (definirano jednom za sve uploade)
                const fetchWithTimeout = (url, options, timeout = 60000) => {
                    return Promise.race([
                        fetch(url, options),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Request timeout - upload took too long')), timeout)
                        )
                    ]);
                };
                
                // JEDNOSTAVNO: Blob je veƒá kreiran u processSelectedFile(), samo ga uploadaj!
                console.log('üîç Preparing Blob for upload...');
                console.log('Blob type:', image1File.type);
                console.log('Blob size:', (image1File.size / 1024 / 1024).toFixed(2), 'MB');
                
                let image1Url;
                try {
                    // Korak 1: Pretvori Blob u base64 (Blob je veƒá clean, kreiran u processSelectedFile)
                    console.log('üì¶ Converting Blob to base64...');
                    const base64 = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(image1File); // image1File je zapravo Blob!
                    });
                    
                    console.log('‚úÖ Base64 created, length:', base64.length);
                    
                    // Korak 2: Upload base64 kroz Netlify funkciju
                    console.log('üì§ Uploading to Netlify function...');
                    const upload1Response = await fetchWithTimeout('/.netlify/functions/upload-user-image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            imageBase64: base64,
                            filename: image1Filename
                        })
                    }, 60000);
                    
                    if (!upload1Response || upload1Response.constructor?.name === 'ProgressEvent') {
                        throw new Error('Network error - connection failed. Please check your internet connection and try again.');
                    }
                    
                    if (!upload1Response.ok) {
                        const errorText = await upload1Response.text();
                        let errorMsg = 'Upload failed';
                        try {
                            const errorData = JSON.parse(errorText);
                            errorMsg = errorData.error || errorData.details || errorMsg;
                        } catch (e) {
                            errorMsg = errorText || errorMsg;
                        }
                        throw new Error(errorMsg);
                    }
                    
                    const upload1Result = await upload1Response.json();
                    if (!upload1Result.success) {
                        throw new Error(upload1Result.error || upload1Result.details || 'Failed to upload image1');
                    }
                    
                    image1Url = upload1Result.url;
                    console.log('‚úÖ Image1 uploaded successfully:', image1Url);
                    
                    // FINALNA PROVJERA: Da li imamo image1Url?
                    if (!image1Url) {
                        throw new Error('Upload completed but no URL returned');
                    }
                    console.log('‚úÖ‚úÖ‚úÖ FINAL CHECK: image1Url is valid:', image1Url);
                    
                } catch (uploadError) {
                    console.error('‚ùå‚ùå‚ùå Upload error:', uploadError);
                    console.error('‚ùå‚ùå‚ùå Upload error type:', uploadError.constructor?.name);
                    console.error('‚ùå‚ùå‚ùå Upload error message:', uploadError.message);
                    console.error('‚ùå‚ùå‚ùå Upload error stack:', uploadError.stack);
                    
                    if (uploadError.message && uploadError.message.includes('timeout')) {
                        throw new Error('Upload timeout - please check your internet connection and try again.');
                    } else if (uploadError.message && (uploadError.message.includes('Failed to fetch') || uploadError.message.includes('CORS'))) {
                        // Provjeri da li je ureƒëaj stvarno offline
                        if (!navigator.onLine) {
                            throw new Error('Network error - could not connect to server. Please check your internet connection.');
                        } else {
                            throw new Error('Server connection failed - please try again. If the problem persists, check your connection.');
                        }
                    } else if (uploadError.constructor && uploadError.constructor.name === 'ProgressEvent') {
                        // Provjeri da li je ureƒëaj stvarno offline
                        if (!navigator.onLine) {
                            throw new Error('Network connection failed. Please check your internet and try again.');
                        } else {
                            throw new Error('Upload failed - please try again. If the problem persists, check your connection.');
                        }
                    } else {
                        throw new Error('Failed to upload image1: ' + (uploadError.message || 'Upload error'));
                    }
                }
                
                // Uploadaj image2 ako postoji - kroz Netlify funkciju
                let image2Url = null;
                if (!isCouple && uploadedImages.person2) {
                    updateLoadingStep(1, 'Uploading second image...');
                    
                    const image2Filename = `${userId}-image2.jpg`;
                    let image2File = uploadedImages.person2;
                    
                    console.log('üì§ Uploading image2 Blob...');
                    console.log('Image2 Blob size:', (image2File.size / 1024 / 1024).toFixed(2), 'MB');
                    
                    try {
                        // Korak 1: Pretvori Blob u base64 (Blob je veƒá kreiran u processSelectedFile)
                        console.log('üì¶ Converting Blob2 to base64...');
                        const base64_2 = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(image2File); // image2File je zapravo Blob!
                        });
                        
                        console.log('‚úÖ Base64_2 created, length:', base64_2.length);
                        
                        // Korak 2: Upload base64 kroz Netlify funkciju
                        const upload2Response = await fetchWithTimeout('/.netlify/functions/upload-user-image', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                imageBase64: base64_2,
                                filename: image2Filename
                            })
                        }, 60000);
                        
                        if (!upload2Response || upload2Response.constructor?.name === 'ProgressEvent') {
                            throw new Error('Network error - connection failed.');
                        }
                        
                        if (!upload2Response.ok) {
                            const errorText = await upload2Response.text();
                            let errorMsg = 'Upload failed';
                            try {
                                const errorData = JSON.parse(errorText);
                                errorMsg = errorData.error || errorData.details || errorMsg;
                            } catch (e) {
                                errorMsg = errorText || errorMsg;
                            }
                            throw new Error(errorMsg);
                        }
                        
                        const upload2Result = await upload2Response.json();
                        if (!upload2Result.success) {
                            throw new Error(upload2Result.error || upload2Result.details || 'Failed to upload image2');
                        }
                        
                        image2Url = upload2Result.url;
                        console.log('‚úÖ Image2 uploaded successfully:', image2Url);
                        
                    } catch (upload2Error) {
                        console.error('Upload error for image2:', upload2Error);
                        
                        if (upload2Error.message && upload2Error.message.includes('timeout')) {
                            throw new Error('Upload timeout - please check your internet connection and try again.');
                        } else if (upload2Error.message && upload2Error.message.includes('Failed to fetch')) {
                            // Provjeri da li je ureƒëaj stvarno offline
                            if (!navigator.onLine) {
                                throw new Error('Network error - could not connect to server. Please check your internet connection.');
                            } else {
                                throw new Error('Server connection failed - please try again. If the problem persists, check your connection.');
                            }
                        } else if (upload2Error.constructor && upload2Error.constructor.name === 'ProgressEvent') {
                            // Provjeri da li je ureƒëaj stvarno offline
                            if (!navigator.onLine) {
                                throw new Error('Network connection failed. Please check your internet and try again.');
                            } else {
                                throw new Error('Upload failed - please try again. If the problem persists, check your connection.');
                            }
                        } else {
                            throw new Error('Failed to upload image2: ' + (upload2Error.message || 'Upload error'));
                        }
                    }
                }
                
                // SADA: Pozovi Netlify Function za generiranje s URL-ovima (mali request!)
                updateLoadingStep(2, 'Starting AI generation...');
                console.log('Calling generate-image function with URLs...');
                
                // Validacija URL-ova prije slanja
                console.log('üîçüîçüîç PRE-GENERATE VALIDATION:');
                console.log('üîç image1Url:', image1Url);
                console.log('üîç image1Url type:', typeof image1Url);
                console.log('üîç image1Url starts with http:', image1Url ? image1Url.startsWith('http') : 'N/A');
                console.log('üîç image2Url:', image2Url);
                
                if (!image1Url || !image1Url.startsWith('http')) {
                    console.error('‚ùå‚ùå‚ùå Invalid image1Url:', image1Url);
                    throw new Error('Invalid image1 URL. Please try uploading the image again.');
                }
                if (image2Url && !image2Url.startsWith('http')) {
                    console.error('‚ùå‚ùå‚ùå Invalid image2Url:', image2Url);
                    throw new Error('Invalid image2 URL. Please try uploading the image again.');
                }
                
                console.log('‚úÖ‚úÖ‚úÖ URL validation passed, proceeding to generate-image...');
                
                console.log('üöÄüöÄüöÄ CALLING generate-image function...');
                console.log('üöÄ Request payload:', {
                    templateId: currentTemplate.id,
                    image1Url: image1Url ? image1Url.substring(0, 50) + '...' : 'MISSING',
                    image2Url: image2Url ? image2Url.substring(0, 50) + '...' : null,
                    isCouple: isCouple
                });
                
                let generateResponse;
                try {
                    generateResponse = await fetchWithTimeout('/.netlify/functions/generate-image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            templateId: currentTemplate.id,
                            image1Url: image1Url,  // URL umjesto base64!
                            image2Url: image2Url,  // URL umjesto base64!
                            isCouple: isCouple
                        })
                    }, 30000); // 30 sekundi timeout
                    
                    console.log('‚úÖ‚úÖ‚úÖ generate-image response received');
                    console.log('‚úÖ Response status:', generateResponse.status);
                } catch (fetchError) {
                    if (fetchError.message === 'Request timeout') {
                        throw new Error('Request timeout - the server took too long to respond. Please try again.');
                    } else if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                        throw new Error('Network error - please check your internet connection and try again.');
                    } else {
                        throw new Error('Failed to connect to server: ' + fetchError.message);
                    }
                }

                // Provjeri status kod prije svega
                if (generateResponse.status === 0 || !generateResponse.status) {
                    throw new Error('Network error - no response from server. Please check your internet connection.');
                }
                
                // Provjeri Content-Type header
                const contentType = generateResponse.headers.get('content-type') || '';
                const isJson = contentType.includes('application/json');
                
                console.log('Response status:', generateResponse.status);
                console.log('Response statusText:', generateResponse.statusText);
                console.log('Content-Type:', contentType);
                console.log('Is JSON:', isJson);
                
                // Prvo proƒçitaj kao text da vidimo ≈°to se vraƒáa
                let responseText;
                try {
                    responseText = await generateResponse.text();
                    console.log('Response text length:', responseText ? responseText.length : 0);
                    console.log('Response text (first 500 chars):', responseText ? responseText.substring(0, 500) : 'EMPTY');
                } catch (textError) {
                    console.error('Failed to read response text:', textError);
                    throw new Error('Failed to read response from server. Please try again.');
                }
                
                // Provjeri da li je response prazan
                if (!responseText || responseText.trim().length === 0) {
                    console.error('Empty response received. Status:', generateResponse.status);
                    
                    // Razliƒçite poruke ovisno o status kodu
                    if (generateResponse.status === 504) {
                        throw new Error('Gateway timeout - the server took too long to respond. Please try again.');
                    } else if (generateResponse.status === 503) {
                        throw new Error('Service unavailable - the server is temporarily overloaded. Please try again in a few moments.');
                    } else if (generateResponse.status === 502) {
                        throw new Error('Bad gateway - there was an error communicating with the server. Please try again.');
                    } else if (generateResponse.status === 500) {
                        throw new Error('Server error - internal server error occurred. Please try again in a few moments.');
                    } else {
                        throw new Error('Empty response from server (Status: ' + generateResponse.status + '). This might be a timeout or server error. Please try again.');
                    }
                }
                
                // Parse response body samo jednom
                let generateResult;
                try {
                    // Provjeri da li je response valjan JSON prije parsiranja
                    const trimmedText = responseText.trim();
                    if (trimmedText.length === 0) {
                        throw new Error('Response is empty');
                    }
                    
                    if (!trimmedText.startsWith('{') && !trimmedText.startsWith('[')) {
                        // Ako nije JSON, mo≈æda je HTML error page
                        if (trimmedText && (trimmedText.toLowerCase().includes('<html') || trimmedText.toLowerCase().includes('<!doctype'))) {
                            throw new Error('Server returned HTML error page instead of JSON. This usually means the function crashed or timed out.');
                        }
                        throw new Error('Response is not valid JSON. Received: ' + trimmedText.substring(0, 100));
                    }
                    
                    generateResult = JSON.parse(trimmedText);
                } catch (parseError) {
                    // Ako JSON parsing ne uspije, poka≈æi ≈°to se stvarno vratilo
                    console.error('Failed to parse JSON response:', parseError);
                    console.error('Response status:', generateResponse.status);
                    console.error('Response statusText:', generateResponse.statusText);
                    console.error('Response text (first 1000 chars):', responseText ? responseText.substring(0, 1000) : 'EMPTY');
                    
                    // Ako je status error, poku≈°aj objasniti
                    if (generateResponse.status >= 500) {
                        throw new Error('Server error (' + generateResponse.status + '). The server encountered an error. Please try again in a few moments. If the problem persists, contact support.');
                    } else if (generateResponse.status === 504 || generateResponse.status === 408) {
                        throw new Error('Request timeout. The generation might take too long. Please try again with smaller images.');
                    } else if (generateResponse.status === 413) {
                        throw new Error('Request too large. Please try with smaller images (max 10MB).');
                    } else if (parseError?.message && parseError.message.includes('Unexpected end')) {
                        throw new Error('Incomplete response from server. The server response was cut off, likely due to a timeout. Please try again.');
                    } else {
                        // Human-friendly error message
                        let friendlyMessage = 'Failed to parse server response. ';
                        if (parseError.message) {
                            friendlyMessage += parseError.message + '. ';
                        }
                        friendlyMessage += 'Please try again or contact support if the problem persists.';
                        throw new Error(friendlyMessage);
                    }
                }

                if (!generateResponse.ok) {
                    throw new Error(generateResult.error || generateResult.details || 'Generation failed');
                }

                console.log('Generation result:', generateResult);

                if (!generateResult.success || !generateResult.predictionId) {
                    console.error('Missing success or predictionId in result:', {
                        success: generateResult.success,
                        predictionId: generateResult.predictionId,
                        fullResult: generateResult
                    });
                    throw new Error('No prediction ID returned');
                }

                const predictionId = generateResult.predictionId;
                console.log('Prediction ID:', predictionId);
                console.log('Polling for prediction status...');

                // Poll status dok nije "succeeded" ili "failed"
                let statusResult;
                let maxAttempts = 150; // Max 5 minuta (150 * 2 sekunde)
                let attempt = 0;

                // Update to processing step
                updateLoadingStep(3, 'Processing your photos...');

                while (attempt < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 2000)); // ƒåekaj 2 sekunde
                    attempt++;

                    console.log(`Checking prediction status (attempt ${attempt}/${maxAttempts})...`);
                    
                    // Update progress based on attempts (steps 3-5 are for processing)
                    const progressPercent = Math.min(95, 30 + (attempt / maxAttempts) * 60);
                    updateProgress(progressPercent);
                    
                    // Update step based on progress
                    if (attempt < maxAttempts * 0.3) {
                        updateLoadingStep(3, 'Processing your photos...');
                    } else if (attempt < maxAttempts * 0.7) {
                        updateLoadingStep(4, 'Creating transformation...');
                    } else {
                        updateLoadingStep(5, 'Adding final touches...');
                    }
                    
                    // PRODUCTION FIX: Dodaj timeout i error handling za status check
                    let statusResponse;
                    let statusText;
                    try {
                        statusResponse = await fetchWithTimeout(`/.netlify/functions/check-prediction-status?predictionId=${predictionId}`, {
                            method: 'GET'
                        }, 15000); // 15 sekundi timeout za status check
                        
                        if (!statusResponse.ok) {
                            const errorText = await statusResponse.text();
                            console.error('‚ùå Status check failed:', statusResponse.status, errorText);
                            throw new Error(`Status check failed: ${statusResponse.status} ${statusResponse.statusText}`);
                        }
                        
                        statusText = await statusResponse.text();
                        
                        // PRODUCTION FIX: Provjeri da li je response prazan
                        if (!statusText || statusText.trim().length === 0) {
                            console.error('‚ùå Empty status response');
                            throw new Error('Empty response from status check');
                        }
                    } catch (fetchError) {
                        console.error('‚ùå Error fetching prediction status:', fetchError);
                        // Ako je timeout ili network error, poku≈°aj ponovno (ne bacaj gre≈°ku odmah)
                        if (fetchError.message && (fetchError.message.includes('timeout') || fetchError.message.includes('fetch'))) {
                            console.warn('‚ö†Ô∏è Status check timeout/error, retrying...');
                            // Nastavi s poll-om, ali poveƒáaj attempt
                            attempt++;
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            continue;
                        }
                        throw fetchError;
                    }
                    
                    try {
                        statusResult = JSON.parse(statusText);
                    } catch (e) {
                        console.error('‚ùå Failed to parse status response:', e);
                        console.error('Status response text:', statusText);
                        throw new Error('Failed to parse status response: ' + (e.message || 'Invalid JSON'));
                    }

                if (!statusResult || !statusResult.status) {
                    console.error('‚ùå Invalid status result:', statusResult);
                    throw new Error('Invalid status response from server');
                }

                console.log(`Prediction status: ${statusResult.status} (attempt ${attempt})`);

                if (statusResult.status === 'succeeded') {
                    console.log('Generation successful! Image URL:', statusResult.imageUrl);
                    updateLoadingStep(6, 'Generation complete! Uploading to Bunny.net...');
                    updateProgress(95);
                    break;
                    } else if (statusResult.status === 'failed') {
                        throw new Error(statusResult.error || 'Generation failed');
                    } else if (statusResult.status === 'canceled') {
                        throw new Error('Generation was canceled');
                    }
                    // Ako je "starting" ili "processing", nastavi poll-ati
                }

                if (attempt >= maxAttempts) {
                    throw new Error('Generation timeout - prediction took too long');
                }

                if (!statusResult.imageUrl) {
                    throw new Error('No image URL in result');
                }

                // Upload na Bunny.net
                console.log('Uploading to Bunny.net...');
                console.log('Calling upload-to-bunny with:', {
                    imageUrl: statusResult.imageUrl,
                    templateId: currentTemplate.id,
                    userId: generateUserId()
                });
                const uploadResponse = await fetch('/.netlify/functions/upload-to-bunny', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        imageUrl: statusResult.imageUrl,
                        templateId: currentTemplate.id,
                        userId: generateUserId() // Generiraj unique user ID
                    })
                });

                // Parse response body samo jednom
                let uploadResult;
                try {
                    uploadResult = await uploadResponse.json();
                } catch (e) {
                    // Ako json() ne uspije, body je veƒá potro≈°en - ne poku≈°avaj ƒçitati text()
                    console.error('Failed to parse upload JSON response:', e);
                    throw new Error('Failed to parse upload response: ' + (e.message || 'Invalid JSON'));
                }

                if (!uploadResponse.ok) {
                    throw new Error(uploadResult.error || uploadResult.details || 'Upload failed');
                }

                console.log('Upload result:', uploadResult);

                // Prika≈æi rezultate
                showResults(uploadResult.cdnUrl, null);
                
            } catch (error) {
                console.error('Generation error:', error);
                console.error('Error type:', typeof error);
                console.error('Error details:', {
                    message: error?.message,
                    name: error?.name,
                    stack: error?.stack,
                    toString: error?.toString()
                });
                
                // ANDROID FIX: Better handling for ProgressEvent errors
                let errorMessage = 'An error occurred while generating your transformation.';
                
                // Detaljno logiranje za debugging (posebno va≈æno za Android)
                console.error('=== ERROR DETAILS ===');
                console.error('Error object:', error);
                console.error('Error type:', typeof error);
                console.error('Error constructor:', error?.constructor?.name);
                console.error('Error keys:', error ? Object.keys(error) : 'N/A');
                
                // ANDROID FIX: Specific handling for ProgressEvent
                if (error?.constructor?.name === 'ProgressEvent') {
                    errorMessage = 'Network error - connection failed. Please check your internet connection and try again.';
                    console.error('ProgressEvent detected - network failure');
                    console.error('ProgressEvent type:', error.type);
                    console.error('ProgressEvent loaded:', error.loaded);
                    console.error('ProgressEvent total:', error.total);
                } else if (error) {
                    // Provjeri razliƒçite naƒçine kako error mo≈æe biti predstavljen
                    if (error.message && typeof error.message === 'string' && error.message.trim().length > 0) {
                        errorMessage = error.message;
                    } else if (typeof error === 'string' && error.trim().length > 0) {
                        errorMessage = error;
                    } else if (error.toString && typeof error.toString === 'function') {
                        const errorString = error.toString();
                        if (errorString !== '[object Object]' && errorString !== '[object Error]' && errorString !== '[object ProgressEvent]') {
                            errorMessage = errorString;
                        } else if (errorString === '[object ProgressEvent]') {
                            errorMessage = 'Network connection error. Please check your internet and try again.';
                        }
                    } else if (error.name && typeof error.name === 'string') {
                        errorMessage = `Error: ${error.name}`;
                    } else if (error.error && typeof error.error === 'string') {
                        errorMessage = error.error;
                    } else {
                        // Fallback - poku≈°aj izvuƒái bilo ≈°to korisno
                        try {
                            const errorJson = JSON.stringify(error);
                            if (errorJson && errorJson !== '{}' && errorJson !== 'null') {
                                errorMessage = `Error: ${errorJson.substring(0, 200)}`;
                            }
                        } catch (e) {
                            // Ako ni JSON.stringify ne radi, koristi default poruku
                            errorMessage = 'An unexpected error occurred. Please try again or contact support if the problem persists.';
                        }
                    }
                }
                
                // Ako je error message jo≈° uvijek prazan ili "undefined", koristi default
                if (!errorMessage || errorMessage.trim().length === 0 || errorMessage === 'undefined') {
                    errorMessage = 'An unexpected error occurred. Please try again or contact support if the problem persists.';
                }
                
                console.error('Final error message:', errorMessage);
                
                showError(errorMessage, true);
                document.getElementById('loadingSection').style.display = 'none';
                document.getElementById('generateButton').disabled = false;
                updateProgress(0); // Reset progress
            }
        });

        // ============================================
        // CANVAS ‚Üí BLOB CONVERSION (Rje≈°ava File object probleme)
        // ============================================
        async function convertFileToCleanBlob(file, quality = 0.9) {
            return new Promise((resolve, reject) => {
                console.log('üé® Converting File to clean Blob via Canvas...');
                console.log('Input file:', {
                    name: file.name,
                    type: file.type,
                    size: (file.size / 1024 / 1024).toFixed(2) + ' MB'
                });
                
                // Kreiraj nevidljivi canvas u memoriji
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    try {
                        // Postavi dimenzije canvas-a
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                        
                        // Nacrtaj sliku na canvas
                        ctx.drawImage(img, 0, 0);
                        
                        // Pretvori canvas u ƒçisti Blob
                        canvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('Failed to create Blob from canvas'));
                                return;
                            }
                            
                            console.log('‚úÖ Clean Blob created:', {
                                size: (blob.size / 1024 / 1024).toFixed(2) + ' MB',
                                type: blob.type
                            });
                            
                            // Cleanup
                            URL.revokeObjectURL(img.src);
                            
                            resolve(blob);
                        }, 'image/jpeg', quality);
                        
                    } catch (error) {
                        console.error('‚ùå Canvas processing error:', error);
                        URL.revokeObjectURL(img.src);
                        reject(error);
                    }
                };
                
                img.onerror = (error) => {
                    console.error('‚ùå Image load error:', error);
                    URL.revokeObjectURL(img.src);
                    reject(new Error('Failed to load image for canvas processing'));
                };
                
                // Uƒçitaj sliku iz File objekta
                img.src = URL.createObjectURL(file);
            });
        }

        // ============================================
        // HEIC CONVERSION
        // ============================================
        async function convertHeicToJpegInBrowser(file) {
            const isHeic = (file.type && (file.type === 'image/heic' || file.type === 'image/heif')) || 
                           (file.name && (file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')));
            
            if (!isHeic) {
                return file; // Nije HEIC, vrati original
            }
            
            console.log('Converting HEIC to JPEG:', file.name);
            
            try {
                // Provjeri je li biblioteka uƒçitana
                if (typeof heic2any === 'undefined') {
                    throw new Error('HEIC converter library not loaded');
                }
                
                // Konvertuj HEIC u JPEG
                const jpegBlob = await heic2any({
                    blob: file,
                    toType: 'image/jpeg',
                    quality: 0.85 // 85% kvalitete
                });
                
                // heic2any vraƒáa array ako je vi≈°e slika, uzmi prvu
                const blob = Array.isArray(jpegBlob) ? jpegBlob[0] : jpegBlob;
                
                // Kreiraj novi File objekt
                const jpegFile = new File([blob], 
                    (file.name ? file.name.replace(/\.(heic|heif)$/i, '.jpg') : 'converted.jpg'), {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                
                console.log('HEIC conversion successful:', {
                    original: `${(file.size / 1024 / 1024).toFixed(2)}MB (${file.type})`,
                    converted: `${(blob.size / 1024 / 1024).toFixed(2)}MB (image/jpeg)`
                });
                
                return jpegFile;
                
            } catch (error) {
                console.error('HEIC conversion failed:', error);
                throw new Error(`Cannot convert HEIC image: ${error.message}. Please save as JPEG first.`);
            }
        }

        // ============================================
        // IMAGE VALIDATION
        // ============================================
        function validateImage(file) {
            return new Promise((resolve, reject) => {
                console.log('üîç Validating image:', {
                    name: file?.name,
                    type: file?.type,
                    size: file?.size,
                    constructor: file?.constructor?.name
                });
                
                // Provjeri da li File objekt postoji i je li validan
                if (!file) {
                    reject(new Error('No file provided'));
                    return;
                }
                
                // Provjeri da li je File objekt ili Blob
                if (!(file instanceof File) && !(file instanceof Blob)) {
                    reject(new Error('Invalid file object - not a File or Blob'));
                    return;
                }
                
                const minWidth = 400;
                const minHeight = 400;
                const maxSize = 10 * 1024 * 1024; // 10MB
                const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/heic', 'image/heif'];
                
                // Provjeri ekstenziju za Samsung HEIC (sa provjerom da file.name i file.type postoje)
                const fileName = file.name ? file.name.toLowerCase() : '';
                const isHeic = fileName && (fileName.endsWith('.heic') || fileName.endsWith('.heif'));
                const isAllowedType = (file.type && allowedTypes.includes(file.type)) || isHeic;
                
                // Check file type
                if (!isAllowedType) {
                    reject(new Error(`Invalid file type (${file.type || 'unknown'}). Samsung users: Please save as JPEG or disable Motion Photo.`));
                    return;
                }
                
                // Check file size (provjeri da li size postoji)
                if (file.size !== undefined && file.size !== null) {
                    if (file.size === 0) {
                        reject(new Error('File is empty'));
                        return;
                    }
                    if (file.size > maxSize) {
                        reject(new Error(`Image too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Maximum size: 10MB`));
                        return;
                    }
                } else {
                    console.warn('‚ö†Ô∏è File size is undefined, skipping size check');
                }
                
                // Check image dimensions
                let objectURL;
                try {
                    objectURL = URL.createObjectURL(file);
                    if (!objectURL) {
                        reject(new Error('Failed to create object URL from file'));
                        return;
                    }
                } catch (urlError) {
                    console.error('‚ùå Error creating object URL:', urlError);
                    reject(new Error('Invalid file - cannot create preview URL'));
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    try {
                        if (img.width < minWidth || img.height < minHeight) {
                            reject(new Error(`Image too small (${img.width}x${img.height}px). Minimum: ${minWidth}x${minHeight}px`));
                        } else {
                            console.log('‚úÖ Image validation successful:', {
                                width: img.width,
                                height: img.height,
                                size: file.size,
                                type: file.type
                            });
                            resolve({ 
                                width: img.width, 
                                height: img.height,
                                size: file.size,
                                type: file.type
                            });
                        }
                    } finally {
                        if (objectURL) {
                            URL.revokeObjectURL(objectURL);
                        }
                    }
                };
                img.onerror = (error) => {
                    console.error('‚ùå Image load error:', error);
                    if (objectURL) {
                        URL.revokeObjectURL(objectURL);
                    }
                    reject(new Error('Invalid image file. Please choose a valid image.'));
                };
                img.src = objectURL;
            });
        }
        
        function showValidationMessage(message, type = 'success') {
            const validationDiv = document.getElementById('validationMessage');
            validationDiv.textContent = message;
            validationDiv.className = `validation-message ${type} show`;
            setTimeout(() => {
                validationDiv.classList.remove('show');
            }, 5000);
        }
        
        // ============================================
        // PROGRESS TRACKING
        // ============================================
        const loadingStates = [
            { step: 1, message: 'Uploading images...', icon: 'üì§', estimatedTime: 5 },
            { step: 2, message: 'Starting AI generation...', icon: 'ü§ñ', estimatedTime: 5 },
            { step: 3, message: 'Processing your photos...', icon: '‚ú®', estimatedTime: 30 },
            { step: 4, message: 'Creating transformation...', icon: 'üé®', estimatedTime: 60 },
            { step: 5, message: 'Adding final touches...', icon: 'üé≠', estimatedTime: 20 },
            { step: 6, message: 'Complete! Preparing download...', icon: '‚úÖ', estimatedTime: 5 }
        ];
        
        let currentStep = 0;
        let startTime = null;
        
        function updateLoadingStep(step, customMessage = null) {
            if (step < 1 || step > loadingStates.length) return;
            
            currentStep = step;
            const state = loadingStates[step - 1];
            
            // Update step indicators
            for (let i = 1; i <= loadingStates.length; i++) {
                const stepEl = document.getElementById(`step${i}`);
                if (stepEl) {
                    stepEl.classList.remove('active', 'completed');
                    if (i < step) {
                        stepEl.classList.add('completed');
                    } else if (i === step) {
                        stepEl.classList.add('active');
                    }
                }
            }
            
            // Update loading message
            const loadingMessage = document.getElementById('loadingMessage');
            const stepIcon = document.getElementById('stepIcon');
            if (loadingMessage) {
                loadingMessage.textContent = customMessage || state.message;
            }
            if (stepIcon) {
                stepIcon.textContent = state.icon;
            }
            
            // Update progress bar
            const progressPercent = ((step - 1) / (loadingStates.length - 1)) * 100;
            updateProgress(progressPercent);
        }
        
        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) {
                progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            }
            
            if (progressText) {
                progressText.textContent = `${Math.round(percent)}%`;
            }
            
            // Update time estimate
            if (startTime && percent > 0 && percent < 100) {
                const elapsed = (Date.now() - startTime) / 1000;
                const estimated = elapsed / (percent / 100);
                const remaining = Math.max(0, estimated - elapsed);
                updateTimeEstimate(remaining);
            }
        }
        
        function updateTimeEstimate(remainingSeconds) {
            const timeEstimate = document.getElementById('timeEstimate');
            if (timeEstimate && remainingSeconds > 0) {
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = Math.floor(remainingSeconds % 60);
                if (minutes > 0) {
                    timeEstimate.textContent = `Estimated time remaining: ~${minutes} minute${minutes > 1 ? 's' : ''}`;
                } else {
                    timeEstimate.textContent = `Estimated time remaining: ~${seconds} second${seconds > 1 ? 's' : ''}`;
                }
            }
        }
        
        function startProgressTracking() {
            startTime = Date.now();
            currentStep = 0;
            updateLoadingStep(1);
        }
        
        // ============================================
        // ERROR RECOVERY & RETRY
        // ============================================
        let lastGenerationData = null;
        
        function saveGenerationData(data) {
            lastGenerationData = {
                ...data,
                timestamp: Date.now()
            };
            // Also save to localStorage for persistence
            try {
                localStorage.setItem('lastGenerationData', JSON.stringify(lastGenerationData));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }
        
        function retryGeneration() {
            if (!lastGenerationData) {
                showError('No previous generation data found. Please upload images again.');
                return;
            }
            
            // Check network connection before retry
            if (!navigator.onLine) {
                showError('No internet connection. Please connect to the internet and try again.', false);
                return;
            }
            
            // Hide error recovery
            document.getElementById('errorRecovery').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
            
            // Show network checking message
            showValidationMessage('üîç Checking network connection...', 'warning');
            
            // Small delay to show message
            setTimeout(() => {
                // Restore images if they exist
                if (lastGenerationData.uploadedImages) {
                    uploadedImages = lastGenerationData.uploadedImages;
                    updatePreview();
                }
                
                // Retry generation
                document.getElementById('generateButton').click();
            }, 1000);
        }
        
        function saveProgress() {
            try {
                const progressData = {
                    templateId: currentTemplate?.id,
                    uploadedImages: uploadedImages,
                    timestamp: Date.now()
                };
                localStorage.setItem('lovestoriesProgress', JSON.stringify(progressData));
                showValidationMessage('‚úÖ Progress saved! You can continue later.', 'success');
            } catch (e) {
                showValidationMessage('‚ùå Could not save progress: ' + e.message, 'error');
            }
        }
        
        function loadSavedProgress() {
            try {
                const saved = localStorage.getItem('lovestoriesProgress');
                if (saved) {
                    const progressData = JSON.parse(saved);
                    // Note: File objects can't be stored in localStorage
                    // This would need to be implemented differently if needed
                    showValidationMessage('üíæ Saved progress found! Upload your images again to continue.', 'warning');
                }
            } catch (e) {
                console.warn('Could not load saved progress:', e);
            }
        }
        
        // ============================================
        // IMPROVED ERROR HANDLING
        // ============================================
        function showError(message, showRetry = true) {
            const errorDiv = document.getElementById('errorMessage');
            const errorContent = document.getElementById('errorContent');
            const errorRecovery = document.getElementById('errorRecovery');
            
            if (errorContent) {
                errorContent.textContent = message;
            }
            
            if (errorDiv) {
                errorDiv.style.display = 'block';
            }
            
            // ANDROID FIX: Provjeri da li je stvarno network error ili samo upload/server error
            const isNetworkError = message && (message.includes('Network') || 
                                  message.includes('connection') || 
                                  message.includes('internet'));
            
            // Provjeri da li je ureƒëaj stvarno offline
            const isActuallyOffline = !navigator.onLine;
            
            // Ako je ureƒëaj online, ali poruka sugerira network error, to je vjerojatno server/upload error
            const isServerError = isNetworkError && !isActuallyOffline;
            
            if (errorRecovery && (showRetry || isNetworkError)) {
                errorRecovery.style.display = 'block';
                
                // Update retry button text ovisno o tipu gre≈°ke
                const retryButton = errorRecovery.querySelector('.retry-button');
                if (retryButton) {
                    if (isActuallyOffline) {
                        retryButton.textContent = 'üîÑ Retry (Network Issue)';
                    } else if (isServerError) {
                        retryButton.textContent = 'üîÑ Retry (Server Issue)';
                    } else if (isNetworkError) {
                        retryButton.textContent = 'üîÑ Retry';
                    } else {
                        retryButton.textContent = 'üîÑ Retry';
                    }
                }
            } else if (errorRecovery) {
                errorRecovery.style.display = 'none';
            }
            
            // Hide loading section
            document.getElementById('loadingSection').style.display = 'none';
            document.getElementById('generateButton').disabled = false;
        }
        
        // ============================================
        // Helper funkcije
        // ============================================
        
        /**
         * Kompresira sliku u browseru prije uploada
         * Smanjuje veliƒçinu na max 2MB za mobilne uploads
         */
        async function compressImage(file, maxSizeMB = 2) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Izraƒçunaj optimalne dimenzije (max 2000px ≈°irina/visina)
                        const maxDimension = 2000;
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > maxDimension || height > maxDimension) {
                            if (width > height) {
                                height = (height / width) * maxDimension;
                                width = maxDimension;
                            } else {
                                width = (width / height) * maxDimension;
                                height = maxDimension;
                            }
                        }
                        
                        // Kreiraj canvas za kompresiju
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        
                        // Crtaj sliku na canvas
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Kompresiraj s razliƒçitim kvalitetama dok ne dobijemo ≈æeljenu veliƒçinu
                        const maxSizeBytes = maxSizeMB * 1024 * 1024;
                        let quality = 0.85; // Poƒçni s 85% kvalitetom
                        let compressedBlob;
                        
                        const tryCompress = () => {
                            canvas.toBlob((blob) => {
                                if (!blob) {
                                    reject(new Error('Failed to compress image'));
                                    return;
                                }
                                
                                console.log(`Compression attempt: ${(blob.size / 1024 / 1024).toFixed(2)}MB (quality: ${(quality * 100).toFixed(0)}%)`);
                                
                                if (blob.size <= maxSizeBytes || quality <= 0.3) {
                                    // Ako je dovoljno mala ili smo na minimumu kvalitete
                                    compressedBlob = blob;
                                    const compressedFile = new File([blob], file.name || 'compressed.jpg', {
                                        type: 'image/jpeg',
                                        lastModified: Date.now()
                                    });
                                    console.log(`‚úÖ Image compressed: ${(file.size / 1024 / 1024).toFixed(2)}MB ‚Üí ${(blob.size / 1024 / 1024).toFixed(2)}MB`);
                                    resolve(compressedFile);
                                } else {
                                    // Smanji kvalitetu i poku≈°aj ponovo
                                    quality -= 0.1;
                                    canvas.toBlob(tryCompress, 'image/jpeg', quality);
                                }
                            }, 'image/jpeg', quality);
                        };
                        
                        tryCompress();
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function generateUserId() {
            return 'user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        // ANDROID FIX: Safe function to clear input values without null errors
        function safeClearInput(inputId) {
            const input = document.getElementById(inputId);
            if (input && input.value !== undefined) {
                input.value = '';
                console.log(`Cleared input: ${inputId}`);
            } else {
                console.log(`Input not found or not clearable: ${inputId}`);
            }
        }

        // ANDROID FIX: Clear all related inputs for an image type
        function clearAllInputsForType(imageType) {
            console.log(`Clearing all inputs for: ${imageType}`);
            
            if (imageType === 'couple') {
                safeClearInput('coupleImage');
                safeClearInput('coupleImageGallery');
                safeClearInput('coupleImageCamera');
            } else if (imageType === 'person1') {
                safeClearInput('person1Image');
                safeClearInput('person1ImageGallery');
                safeClearInput('person1ImageCamera');
            } else if (imageType === 'person2') {
                safeClearInput('person2Image');
                safeClearInput('person2ImageGallery');
                safeClearInput('person2ImageCamera');
            }
        }

        function showResults(imageUrl, videoUrl) {
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';
            
            if (imageUrl) {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'result-item';
                    imageDiv.innerHTML = `
                    <h4>üì∏ Transformed Image</h4>
                    <img src="${imageUrl}" alt="Result">
                    <a href="${imageUrl}" download="lovestories-image.jpg" class="download-button">‚¨áÔ∏è Download Image</a>
                `;
                resultsContainer.appendChild(imageDiv);
                
                // Generiraj QR kod za sliku
                generateQRCodeForImage(imageUrl, resultsContainer);
            }
            
            if (videoUrl) {
                const videoDiv = document.createElement('div');
                videoDiv.className = 'result-item';
                videoDiv.innerHTML = `
                    <h4>üé¨ Transformed Video</h4>
                    <video src="${videoUrl}" controls></video>
                    <a href="${videoUrl}" download="lovestories-video.mp4" class="download-button">‚¨áÔ∏è Download Video</a>
                `;
                resultsContainer.appendChild(videoDiv);
            }
            
            document.getElementById('resultsSection').classList.add('show');
            document.getElementById('loadingSection').style.display = 'none';
            
            // Show 100% progress
            updateProgress(100);
            updateLoadingStep(6, 'Complete!');
            
            // Clear saved progress
            try {
                localStorage.removeItem('lovestoriesProgress');
            } catch (e) {
                console.warn('Could not clear saved progress:', e);
            }
        }
        
        // Generiraj QR kod za sliku
        function generateQRCodeForImage(imageUrl, container) {
            const qrDiv = document.createElement('div');
            qrDiv.className = 'result-item';
            qrDiv.style.textAlign = 'center';
            qrDiv.style.padding = '20px';
            qrDiv.style.background = '#f8f9fa';
            qrDiv.style.borderRadius = '12px';
            qrDiv.style.marginTop = '20px';
            qrDiv.innerHTML = '<h4>üì± Scan QR code to access on your phone</h4><div id="qrCodeContainer" style="display: inline-block; padding: 20px; background: white; border-radius: 8px; margin-top: 10px;"></div>';
            container.appendChild(qrDiv);
            
            const qrContainer = qrDiv.querySelector('#qrCodeContainer');
            qrContainer.innerHTML = '<div style="text-align: center; padding: 20px;">Loading QR code...</div>';
            
            // Check if QRCode library is loaded
            if (typeof QRCode === 'undefined') {
                console.error('QRCode library not loaded');
                qrContainer.innerHTML = '<p style="color: red;">QR library not loaded</p>';
                return;
            }
            
            // qrcodejs uses constructor approach
            try {
                // Clear previous QR code
                qrContainer.innerHTML = '';
                
                // Generate QR code using qrcodejs API
                new QRCode(qrContainer, {
                    text: imageUrl,
                    width: 250,
                    height: 250,
                    colorDark: '#667eea',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.M
                });
                
                console.log('QR code generated successfully');
            } catch (error) {
                console.error('QR code error:', error);
                qrContainer.innerHTML = '<p style="color: red;">Error generating QR code</p>';
            }
        }

        // Initialize
        loadTemplateInfo();
        checkGenerateButton();
        loadSavedProgress();
        
        // ANDROID FIX: Setup listeners if using Android fix
        if (useAndroidFix) {
            debugLog('Using Android fix with separate camera/gallery inputs', 'success');
            setupAndroidInputListeners();
            // Hide original buttons, show Android-specific message
            showValidationMessage('üì± Android detected: Using optimized file selection', 'success');
        } else {
            debugLog('Using standard file input approach', 'info');
        }
        
        // Auto-show debug panel on Android for testing
        if (isAndroid) {
            setTimeout(() => {
                debugLog('Android device detected - debug panel available', 'success');
                debugLog(`Network status: ${networkStatus.online ? 'online' : 'offline'}`, 
                        networkStatus.online ? 'success' : 'error');
                // Uncomment next line to auto-show debug panel on Android
                // toggleDebugPanel();
            }, 1000);
        }
        
        // Periodic network check for Android
        if (isAndroid) {
            setInterval(() => {
                checkNetworkStatus();
            }, 10000); // Check every 10 seconds
        }
    </script>
</body>
</html>


